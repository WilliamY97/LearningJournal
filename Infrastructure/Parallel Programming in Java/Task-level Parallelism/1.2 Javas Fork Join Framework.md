# 1.2 Creating Tasks in Java's Fork/Join Framework

In this lecture, we learned how to implement the async and finish functionality using Javaâ€™s standard Fork/Join (FJ) framework.
In this framework, a task can be specified in the ğšŒğš˜ğš–ğš™ğšğšğš() method of a user-defined class that extends the standard RecursiveAction
class in the FJ framework. In our Array Sum example, we created class ğ™°ğš‚ğšğš– with fields ğ™° for the input array, ğ™»ğ™¾ and ğ™·ğ™¸ for the subrange
for which the sum is to be computed, and ğš‚ğš„ğ™¼ for the result for that subrange. For an instance of this user-defined class (e.g., ğ™» in
the lecture), we learned that the method call, ğ™».ğšğš˜ğš›ğš”(), creates a new task that executes ğ™»â€™s ğšŒğš˜ğš–ğš™ğšğšğš() method. This implements the 
functionality of the async construct that we learned earlier. The call to ğ™».ğš“ğš˜ğš’ğš—() then waits until the computation created by ğ™».ğšğš˜ğš›ğš”()
has completed. Note that ğš“ğš˜ğš’ğš—() is a lower-level primitive than finish because ğš“ğš˜ğš’ğš—() waits for a specific task, whereas finish 
implicitly waits for all tasks created in its scope. To implement the finish construct using ğš“ğš˜ğš’ğš—() operations, you have to be sure
to call ğš“ğš˜ğš’ğš—() on every task created in the finish scope.

A sketch of the Java code for the ASum class is as follows:

```
private static class ASum extends RecursiveAction {
  int[] A; // input array
  int LO, HI; // subrange
  int SUM; // return value
  . . .
  @Override
  protected void compute() {
    SUM = 0;
    for (int i = LO; i <= HI; i++) SUM += A[i];
  } // compute()
}
```

FJ tasks are executed in a ForkJoinPool, which is a pool of Java threads. This pool supports the invokeAll() method that combines both
the ğšğš˜ğš›ğš” and ğš“ğš˜ğš’ğš— operations by executing a set of tasks in parallel, and waiting for their completion. For example, ğš’ğš—ğšŸğš˜ğš”ğšğ™°ğš•ğš•(ğš•ğšğšğš,ğš›ğš’ğšğš‘ğš)
implicitly performs ğšğš˜ğš›ğš”() operations on ğš•ğšğšğš and ğš›ğš’ğšğš‘ğš, followed by ğš“ğš˜ğš’ğš—() operations on both objects.
